import numpy as np
import scipy as sc
import pandas as pd
import statsmodels.api as sm
import seaborn as sns
from scipy.stats import norm
import matplotlib.pyplot as plt
from datetime import datetime
from io import BytesIO
import warnings
warnings.simplefilter('ignore')
from statsmodels.nonparametric.smoothers_lowess import lowess
from statsmodels.sandbox.regression.predstd import wls_prediction_std
import ihs_lei
import pickle
import os
from ihs_lei.analytics.filtering import SeasonalAdjustment
from ihs_lei.analytics.leading import LeadingIndicatorAnalysis
from ihs_lei.data.load import EconomicDataLoad, EconomicMetadataLoad


class LeadingIndicatorBuilder(object):
    """
    This builds the leading indicator based on datasets.
    inputs:
        y: pd.Series
        x: dict(data generated by LeadingIndicatorAnalysis object)
    The inputs should be the already filtered/optimal leading series.
    It will iterate over every x and compute the OLS/RLM.
    """
    def __init__(self, reference_series, indicator_dataset):
        self.reference_series = reference_series
        self.indicator_dataset = indicator_dataset
        self._data = ihs_lei.data.load()

        indicators_to_fit = []
        for indicator in indicator_dataset:
            if indicator_dataset[indicator]['valid_model']:
                indicators_to_fit.append(indicator)
        self.indicators_to_fit = indicators_to_fit

    def fit(self):
        """
        Fits the Xs to our Y.
        """
        # Now let's get the dataset.
        df_ols_dataset = {}
        df_rlm_dataset = {}
        for indicator in self.indicators_to_fit:
            indicator_data = self.indicator_dataset[indicator]['analysis_model'].indicator_series
            indicator_data = indicator_data.shift(self.indicator_dataset[indicator]['lead'], freq='M')
            indicator_data_ols = indicator_data * self.indicator_dataset[indicator]['fit']['ols_model'].params[0]
            indicator_data_rlm = indicator_data * self.indicator_dataset[indicator]['fit']['rlm_model'].params[0]
            df_ols_dataset[indicator] = indicator_data_ols
            df_rlm_dataset[indicator] = indicator_data_rlm
        df_ols_dataset = pd.DataFrame(df_ols_dataset)
        df_rlm_dataset = pd.DataFrame(df_rlm_dataset)

def resample_dataseries(series, original_frequency, column_name):
    return series.asfreq(original_frequency, method='ffill').dropna(axis=0, how='all').resample('M').last()[column_name]


class LeadingIndicatorManager(object):
    """
    This manages the leading indicators
    Indicator_series is simply a list with the names of the series in the dataset you want to use.
    Reference series is the name of the reference series.
    """
    def __init__(self, reference_series, indicator_series):
        self._data = EconomicDataLoad()
        self._metadata = EconomicMetadataLoad()
        indicator_lei_series = {}
        for series_name in indicator_series:
            series_data = self._data[series_name]
            try:
                series_frequency = self._metadata[series_name]['resample_information']['frequency']
                series_column = self._metadata[series_name]['resample_information']['column_name']
                indicator_lei_series[series_name] = resample_dataseries(series_data, series_frequency, series_column)
            except:
                print("The indicator {0} does not have resampling information.".format(series_name))
                continue

        indicator_seasonal_data = {}
        for indicator in indicator_lei_series:
            indicator_series = indicator_lei_series[indicator]
            indicator_seasonally_adjusted_model = SeasonalAdjustment(indicator_series)
            indicator_series_fit = indicator_seasonally_adjusted_model.fit()
            indicator_seasonal_data[indicator] = indicator_series_fit

        self._indicator_raw_data = indicator_lei_series
        self._indicator_seasonal_data = indicator_seasonal_data

        lei_reference_series_data = self._data[reference_series]
        lei_reference_series_frequency = self._metadata[reference_series]['resample_information']['frequency']
        lei_reference_series_column = self._metadata[reference_series]['resample_information']['column_name']
        lei_reference_series = resample_dataseries(lei_reference_series_data, lei_reference_series_frequency, lei_reference_series_column)
        lei_reference_seasonal_model = SeasonalAdjustment(lei_reference_series)
        lei_reference_seasonal_fit = lei_reference_seasonal_model.fit()

        self._reference_raw_data = lei_reference_series
        self._reference_seasonal_data = lei_reference_seasonal_fit


        indicator_lead_data = {}
        for indicator in self._indicator_seasonal_data:
            indicator_lead_model = LeadingIndicatorAnalysis(lei_reference_seasonal_fit['cycles'],
                                                      self._indicator_seasonal_data[indicator]['cycles'])
            indicator_lead_model_fit = indicator_lead_model.fit(expected_sign=self._metadata[indicator]['resample_information']['expected_sign'])
            indicator_lead_data[indicator] = indicator_lead_model_fit

        self._indicator_lead_data = indicator_lead_data


    def fit(self):
        """
        Just fits all the indicators to the reference data, if the indicators are valid.
        """
        indicators_to_fit = []
        for indicator in self._indicator_lead_data:
            try:
                if self._indicator_lead_data[indicator]['valid_model']:
                    indicators_to_fit.append(indicator)
                else:
                    print("The indicator {0} has not been selected for the LEI. Reason below.\n".format(indicator) + self._indicator_lead_data[indicator]['reasoning'])
            except:
                print("Weird! The indicator {0} can't be found.".format(indicator))

        df_ols_dataset = {}
        df_rlm_dataset = {}
        for indicator in indicators_to_fit:
            indicator_data = self._indicator_lead_data[indicator]['analysis_model'].indicator_series
            indicator_data = indicator_data.shift(self._indicator_lead_data[indicator]['lead'], freq='M')
            indicator_data_ols = indicator_data * self._indicator_lead_data[indicator]['fit']['ols_model'].params[0]
            indicator_data_rlm = indicator_data * self._indicator_lead_data[indicator]['fit']['rlm_model'].params[0]
            df_ols_dataset[indicator] = indicator_data_ols
            df_rlm_dataset[indicator] = indicator_data_rlm
        df_ols_dataset = pd.DataFrame(df_ols_dataset)
        df_rlm_dataset = pd.DataFrame(df_rlm_dataset)
        df_ols_dataset = df_ols_dataset.sum(axis=1, numeric_only=True)
        df_rlm_dataset = df_rlm_dataset.sum(axis=1, numeric_only=True)
        ols_result = ((df_ols_dataset - min(df_ols_dataset))/(max(df_ols_dataset) - min(df_ols_dataset))*2 - 1)
        rlm_result = ((df_rlm_dataset - min(df_rlm_dataset))/(max(df_rlm_dataset) - min(df_rlm_dataset))*2 - 1)
        result = {
            'ols_result': ols_result,
            'rlm_result': rlm_result
        }

        # Now let's run a final regression
        # The way I'm doing this is using the LeadingIndicatorAnalysis, for easiness
        ols_leading_result = LeadingIndicatorAnalysis(self._reference_seasonal_data['cycles'], ols_result)
        ols_leading_result = ols_leading_result._performance(0)['ols_model'] # Want 0 lead

        rlm_leading_result = LeadingIndicatorAnalysis(self._reference_seasonal_data['cycles'], rlm_result)
        rlm_leading_result = rlm_leading_result._performance(0)['ols_model'] # Want 0 lead

        result = {
            'ols_lei': ols_result,
            'rlm_lei': rlm_result,
            'ols_result': ols_leading_result,
            'rlm_result': rlm_leading_result,

        }

        return result